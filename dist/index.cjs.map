{"version":3,"sources":["../src/utils/preprocess.ts","../src/utils/geometry.ts","../src/analysis/repDetector.ts","../src/analysis/featureAggregator.ts","../src/analysis/ruleEngine.ts"],"names":["feature"],"mappings":"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","file":"index.cjs","sourcesContent":["export interface LetterboxParams {\n  inputSize: number; // model square input (e.g., 256/384/640)\n  scale: number; // scale applied to src -> resized\n  dx: number; // left padding in pixels in model input space\n  dy: number; // top padding in pixels in model input space\n  resized: { width: number; height: number };\n}\n\n/**\n * Compute centered letterbox to fit src into a square inputSize.\n * Returns scale and padding for accurate coordinate unprojection.\n */\nexport function computeLetterbox(srcW: number, srcH: number, inputSize: number): LetterboxParams {\n  const s = Math.min(inputSize / srcW, inputSize / srcH);\n  const newW = Math.round(srcW * s);\n  const newH = Math.round(srcH * s);\n  const dx = Math.floor((inputSize - newW) / 2);\n  const dy = Math.floor((inputSize - newH) / 2);\n  return { inputSize, scale: s, dx, dy, resized: { width: newW, height: newH } };\n}\n\n/**\n * Map point from model input space back to original source pixel space.\n * If model outputs normalized coords [0..1], set normalized=true.\n */\nexport function mapFromLetterbox(\n  x: number,\n  y: number,\n  srcW: number,\n  srcH: number,\n  p: LetterboxParams,\n  normalized = false\n): { x: number; y: number } {\n  const px = normalized ? x * p.inputSize : x;\n  const py = normalized ? y * p.inputSize : y;\n  const ox = Math.max(0, Math.min(srcW, (px - p.dx) / p.scale));\n  const oy = Math.max(0, Math.min(srcH, (py - p.dy) / p.scale));\n  return { x: ox, y: oy };\n}\n","import { Keypoint } from \"../types\";\r\n\r\n/**\r\n * Checks if a keypoint is valid (not null/undefined and has x, y coordinates).\r\n */\r\nexport function isValidKeypoint(keypoint: Keypoint | undefined | null): keypoint is Keypoint {\r\n  return (\r\n    keypoint !== undefined && keypoint !== null && typeof keypoint.x === \"number\" && typeof keypoint.y === \"number\"\r\n  );\r\n}\r\n\r\n/**\r\n * Calculates the 2D angle (in degrees) at point B formed by points A-B-C.\r\n * Returns the interior angle at the middle point (B).\r\n * Returns NaN if any keypoint is invalid.\r\n */\r\nexport function calculateAngle(a: Keypoint | undefined, b: Keypoint | undefined, c: Keypoint | undefined): number {\r\n  if (!isValidKeypoint(a) || !isValidKeypoint(b) || !isValidKeypoint(c)) {\r\n    return NaN;\r\n  }\r\n\r\n  const ba = { x: a.x - b.x, y: a.y - b.y };\r\n  const bc = { x: c.x - b.x, y: c.y - b.y };\r\n\r\n  const dotProduct = ba.x * bc.x + ba.y * bc.y;\r\n  const magnitudeBA = Math.sqrt(ba.x ** 2 + ba.y ** 2);\r\n  const magnitudeBC = Math.sqrt(bc.x ** 2 + bc.y ** 2);\r\n\r\n  if (magnitudeBA === 0 || magnitudeBC === 0) {\r\n    return 0;\r\n  }\r\n\r\n  const cosAngle = Math.max(-1, Math.min(1, dotProduct / (magnitudeBA * magnitudeBC)));\r\n  return Math.acos(cosAngle) * (180 / Math.PI);\r\n}\r\n\r\n/**\r\n * Calculates the 3D angle (in degrees) at point B formed by points A-B-C.\r\n * Falls back to 2D if z coordinates are not available.\r\n * Returns NaN if any keypoint is invalid.\r\n */\r\nexport function calculateAngle3D(a: Keypoint | undefined, b: Keypoint | undefined, c: Keypoint | undefined): number {\r\n  if (!isValidKeypoint(a) || !isValidKeypoint(b) || !isValidKeypoint(c)) {\r\n    return NaN;\r\n  }\r\n\r\n  if (a.z === undefined || b.z === undefined || c.z === undefined) {\r\n    return calculateAngle(a, b, c);\r\n  }\r\n\r\n  const ba = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\r\n  const bc = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };\r\n\r\n  const dotProduct = ba.x * bc.x + ba.y * bc.y + ba.z * bc.z;\r\n  const magnitudeBA = Math.sqrt(ba.x ** 2 + ba.y ** 2 + ba.z ** 2);\r\n  const magnitudeBC = Math.sqrt(bc.x ** 2 + bc.y ** 2 + bc.z ** 2);\r\n\r\n  if (magnitudeBA === 0 || magnitudeBC === 0) {\r\n    return 0;\r\n  }\r\n\r\n  const cosAngle = Math.max(-1, Math.min(1, dotProduct / (magnitudeBA * magnitudeBC)));\r\n  return Math.acos(cosAngle) * (180 / Math.PI);\r\n}\r\n\r\n/**\r\n * Calculates the angle between a line (A-B) and the vertical axis.\r\n * 0째 = vertical (pointing up), 90째 = horizontal.\r\n * Returns NaN if any keypoint is invalid.\r\n */\r\nexport function angleToVertical(a: Keypoint | undefined, b: Keypoint | undefined): number {\r\n  if (!isValidKeypoint(a) || !isValidKeypoint(b)) {\r\n    return NaN;\r\n  }\r\n\r\n  const dx = b.x - a.x;\r\n  const dy = b.y - a.y;\r\n  const angleRad = Math.atan2(Math.abs(dx), Math.abs(dy));\r\n  return angleRad * (180 / Math.PI);\r\n}\r\n\r\n/**\r\n * Calculates the angle between a line (A-B) and the horizontal axis.\r\n * 0째 = horizontal, 90째 = vertical.\r\n * Returns NaN if any keypoint is invalid.\r\n */\r\nexport function angleToHorizontal(a: Keypoint | undefined, b: Keypoint | undefined): number {\r\n  if (!isValidKeypoint(a) || !isValidKeypoint(b)) {\r\n    return NaN;\r\n  }\r\n\r\n  const dx = b.x - a.x;\r\n  const dy = b.y - a.y;\r\n  const angleRad = Math.atan2(Math.abs(dy), Math.abs(dx));\r\n  return angleRad * (180 / Math.PI);\r\n}\r\n\r\n/**\r\n * Calculates the Euclidean distance between two keypoints (2D).\r\n */\r\nexport function distance2D(a: Keypoint, b: Keypoint): number {\r\n  return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);\r\n}\r\n\r\n/**\r\n * Calculates the Euclidean distance between two keypoints (3D).\r\n */\r\nexport function distance3D(a: Keypoint, b: Keypoint): number {\r\n  if (a.z === undefined || b.z === undefined) {\r\n    return distance2D(a, b);\r\n  }\r\n  return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2 + (b.z - a.z) ** 2);\r\n}\r\n\r\n/**\r\n * Returns the midpoint between two keypoints.\r\n */\r\nexport function midpoint(a: Keypoint, b: Keypoint): Keypoint {\r\n  return {\r\n    x: (a.x + b.x) / 2,\r\n    y: (a.y + b.y) / 2,\r\n    z: a.z !== undefined && b.z !== undefined ? (a.z + b.z) / 2 : undefined,\r\n    visibility:\r\n      a.visibility !== undefined && b.visibility !== undefined ? (a.visibility + b.visibility) / 2 : undefined,\r\n  };\r\n}\r\n\r\n/**\r\n * Checks if a keypoint has sufficient visibility confidence.\r\n */\r\nexport function isVisible(keypoint: Keypoint, threshold: number = 0.5): boolean {\r\n  return keypoint.visibility !== undefined && keypoint.visibility >= threshold;\r\n}\r\n\r\n/**\r\n * Checks if all keypoints have sufficient visibility.\r\n */\r\nexport function allVisible(keypoints: Keypoint[], threshold: number = 0.5): boolean {\r\n  return keypoints.every((kp) => isVisible(kp, threshold));\r\n}\r\n","import { PhaseType } from \"../types\";\r\n\r\nexport class RepDetector {\r\n  private state: PhaseType = \"IDLE\";\r\n  private hipYHistory: number[] = [];\r\n\r\n  // Thresholds for vertical movement detection (in pixels)\r\n  private readonly MOVEMENT_THRESHOLD = 7; // Minimum movement to detect phase change\r\n  private readonly HISTORY_SIZE = 10; // Frames to average for smoothing\r\n\r\n  /**\r\n   * Detects the current phase based on hip vertical position.\r\n   * @param hipY - The Y coordinate of the hip (midpoint of left and right hip)\r\n   */\r\n  detect(hipY: number): {\r\n    state: PhaseType;\r\n    isRepFinished: boolean;\r\n    velocity: number;\r\n  } {\r\n    let isRepFinished = false;\r\n\r\n    this.hipYHistory.push(hipY);\r\n    if (this.hipYHistory.length > this.HISTORY_SIZE) {\r\n      this.hipYHistory.shift();\r\n    }\r\n\r\n    // Guard against NaN or undefined hipY\r\n    if (isNaN(hipY) || hipY === undefined) {\r\n      return {\r\n        state: this.state,\r\n        isRepFinished,\r\n        velocity: 0,\r\n      };\r\n    }\r\n\r\n    // Need enough history to calculate movement\r\n    if (this.hipYHistory.length < 3) {\r\n      return { state: this.state, isRepFinished, velocity: 0 };\r\n    }\r\n\r\n    // Calculate smoothed velocity (positive = moving down, negative = moving up)\r\n    const recentAvg = this.getRecentAverage(3);\r\n    const olderAvg = this.getOlderAverage(3);\r\n    const velocity = recentAvg - olderAvg;\r\n\r\n    switch (this.state) {\r\n      case \"IDLE\":\r\n        // If hip moves down significantly, start descending\r\n        if (velocity > this.MOVEMENT_THRESHOLD) {\r\n          this.state = \"DESCENDING\";\r\n        }\r\n        break;\r\n\r\n      case \"DESCENDING\":\r\n        // If hip starts moving up, switch to ascending\r\n        if (velocity < -this.MOVEMENT_THRESHOLD) {\r\n          this.state = \"ASCENDING\";\r\n        }\r\n        break;\r\n\r\n      case \"ASCENDING\":\r\n        // If hip reaches near starting position or stops moving up\r\n        if (velocity > this.MOVEMENT_THRESHOLD) {\r\n          // Started going back down\r\n          this.state = \"DESCENDING\";\r\n        } else if (Math.abs(velocity) < this.MOVEMENT_THRESHOLD / 2) {\r\n          // Stopped moving - rep complete\r\n          const startY = this.hipYHistory[0];\r\n          const currentY = hipY;\r\n          // Check if returned to approximately starting position\r\n          if (Math.abs(currentY - startY) < this.MOVEMENT_THRESHOLD * 2) {\r\n            this.state = \"IDLE\";\r\n            isRepFinished = true;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    return { state: this.state, isRepFinished, velocity };\r\n  }\r\n\r\n  /**\r\n   * Gets average of most recent N frames.\r\n   */\r\n  private getRecentAverage(n: number): number {\r\n    const recent = this.hipYHistory.slice(-n);\r\n    return recent.reduce((a, b) => a + b, 0) / recent.length;\r\n  }\r\n\r\n  /**\r\n   * Gets average of frames before the most recent N frames.\r\n   */\r\n  private getOlderAverage(n: number): number {\r\n    const older = this.hipYHistory.slice(0, -n);\r\n    if (older.length === 0) return this.hipYHistory[0];\r\n    return older.reduce((a, b) => a + b, 0) / older.length;\r\n  }\r\n\r\n  /**\r\n   * Gets the current state.\r\n   */\r\n  getState(): PhaseType {\r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Resets the detector for a new set.\r\n   */\r\n  reset(): void {\r\n    this.state = \"IDLE\";\r\n    this.hipYHistory = [];\r\n  }\r\n}\r\n","import { RepAggregates, PhaseAggregates, PhaseType } from \"../types\";\r\n\r\nexport class FeatureAggregator {\r\n  private currentPhase: PhaseType = \"IDLE\";\r\n\r\n  // Rep-level aggregates\r\n  private repData: { [key: string]: number[] } = {};\r\n\r\n  // Phase-level aggregates\r\n  private phaseData: {\r\n    IDLE: { [key: string]: number[] };\r\n    DESCENDING: { [key: string]: number[] };\r\n    ASCENDING: { [key: string]: number[] };\r\n  } = {\r\n    IDLE: {},\r\n    DESCENDING: {},\r\n    ASCENDING: {},\r\n  };\r\n\r\n  /**\r\n   * Sets the current phase for aggregation.\r\n   */\r\n  setPhase(phase: PhaseType): void {\r\n    this.currentPhase = phase;\r\n  }\r\n\r\n  /**\r\n   * Records a feature value for the current frame.\r\n   * Automatically aggregates at both rep and phase level.\r\n   */\r\n  recordFeature(featureName: string, value: number): void {\r\n    if (isNaN(value)) return;\r\n\r\n    // Rep-level\r\n    if (!this.repData[featureName]) {\r\n      this.repData[featureName] = [];\r\n    }\r\n    this.repData[featureName].push(value);\r\n\r\n    // Phase-level\r\n    if (!this.phaseData[this.currentPhase][featureName]) {\r\n      this.phaseData[this.currentPhase][featureName] = [];\r\n    }\r\n    this.phaseData[this.currentPhase][featureName].push(value);\r\n  }\r\n\r\n  /**\r\n   * Convenience method to record common squat features.\r\n   */\r\n  processFrame(kneeFlexionLeft: number, kneeFlexionRight: number, trunkAngle: number, stanceWidth: number): void {\r\n    const kneeFlexion = (kneeFlexionLeft + kneeFlexionRight) / 2;\r\n\r\n    this.recordFeature(\"knee_flexion\", kneeFlexion);\r\n    this.recordFeature(\"knee_flexion_left\", kneeFlexionLeft);\r\n    this.recordFeature(\"knee_flexion_right\", kneeFlexionRight);\r\n    this.recordFeature(\"trunk_angle\", trunkAngle);\r\n    this.recordFeature(\"stance_width\", stanceWidth);\r\n  }\r\n\r\n  /**\r\n   * Calculates min value from an array.\r\n   */\r\n  private calcMin(values: number[]): number {\r\n    return values.length > 0 ? Math.min(...values) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Calculates max value from an array.\r\n   */\r\n  private calcMax(values: number[]): number {\r\n    return values.length > 0 ? Math.max(...values) : NaN;\r\n  }\r\n\r\n  /**\r\n   * Calculates mean value from an array.\r\n   */\r\n  private calcMean(values: number[]): number {\r\n    return values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : NaN;\r\n  }\r\n\r\n  /**\r\n   * Calculates standard deviation from an array.\r\n   */\r\n  private calcStd(values: number[]): number {\r\n    if (values.length === 0) return NaN;\r\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\r\n    const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;\r\n    return Math.sqrt(variance);\r\n  }\r\n\r\n  /**\r\n   * Gets rep-level aggregates with all comparator types.\r\n   */\r\n  getRepAggregates(): RepAggregates {\r\n    const result: RepAggregates = {};\r\n\r\n    for (const [feature, values] of Object.entries(this.repData)) {\r\n      result[`${feature}_min`] = this.calcMin(values);\r\n      result[`${feature}_max`] = this.calcMax(values);\r\n      result[`${feature}_mean`] = this.calcMean(values);\r\n      result[`${feature}_std`] = this.calcStd(values);\r\n      // Also include raw feature name with mean for convenience\r\n      result[feature] = values.reduce((a, b) => a + b, 0) / values.length;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets phase-level aggregates with all comparator types.\r\n   */\r\n  getPhaseAggregates(): PhaseAggregates {\r\n    const result: PhaseAggregates = {\r\n      IDLE: {},\r\n      DESCENDING: {},\r\n      ASCENDING: {},\r\n    };\r\n\r\n    for (const phase of [\"IDLE\", \"DESCENDING\", \"ASCENDING\"] as PhaseType[]) {\r\n      for (const [feature, values] of Object.entries(this.phaseData[phase])) {\r\n        result[phase][`${feature}_min`] = this.calcMin(values);\r\n        result[phase][`${feature}_max`] = this.calcMax(values);\r\n        result[phase][`${feature}_mean`] = this.calcMean(values);\r\n        result[phase][`${feature}_std`] = this.calcStd(values);\r\n        result[phase][feature] = values.length > 0 ? values.reduce((a, b) => a + b, 0) / values.length : NaN;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resets all aggregated data for a new rep.\r\n   */\r\n  reset(): void {\r\n    this.currentPhase = \"IDLE\";\r\n    this.repData = {};\r\n    this.phaseData = {\r\n      IDLE: {},\r\n      DESCENDING: {},\r\n      ASCENDING: {},\r\n    };\r\n  }\r\n}\r\n","import { ExerciseConfig, RepAggregates, PhaseAggregates, Feedback, ViewType, RuleConfig } from \"../types\";\r\n\r\nexport interface FrameData {\r\n  knee_flexion: number;\r\n  knee_flexion_left: number;\r\n  knee_flexion_right: number;\r\n  trunk_angle: number;\r\n  stance_width: number;\r\n  [key: string]: number;\r\n}\r\n\r\nexport class RuleEngine {\r\n  private currentView: ViewType = \"front\";\r\n\r\n  // Buffer for frame-level stability calculations\r\n  private frameBuffer: { [feature: string]: number[] } = {};\r\n  private frameFeedbacks: Feedback[] = [];\r\n\r\n  // Debouncing for frame-level errors\r\n  private errorCounts: { [ruleId: string]: number } = {};\r\n  private passCounts: { [ruleId: string]: number } = {};\r\n  private activeErrors: { [ruleId: string]: boolean } = {};\r\n\r\n  // Configuration for debouncing\r\n  private readonly ERROR_TRIGGER_FRAMES = 5; // Consecutive error frames to trigger\r\n  private readonly ERROR_CLEAR_FRAMES = 10; // Consecutive pass frames to clear\r\n\r\n  // Tolerance percentage for \"mean\" comparator (e.g., 0.2 = 20% deviation allowed)\r\n  private readonly MEAN_TOLERANCE = 0.2;\r\n\r\n  constructor(private config: ExerciseConfig) {}\r\n\r\n  /**\r\n   * Sets the current camera view for threshold selection.\r\n   */\r\n  setView(view: ViewType): void {\r\n    this.currentView = view;\r\n  }\r\n\r\n  /**\r\n   * Gets the current camera view.\r\n   */\r\n  getView(): ViewType {\r\n    return this.currentView;\r\n  }\r\n\r\n  /**\r\n   * Gets the threshold for a rule based on the current view.\r\n   */\r\n  private getThreshold(rule: RuleConfig): number | undefined {\r\n    if (rule.type === \"range\") {\r\n      return rule.thresholds?.[this.currentView];\r\n    } else if (rule.type === \"symmetry\") {\r\n      return rule.maxDiff?.[this.currentView];\r\n    } else if (rule.type === \"stability\") {\r\n      return rule.maxStd?.[this.currentView];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Calculates standard deviation of an array of numbers.\r\n   */\r\n  private calcStd(values: number[]): number {\r\n    if (values.length === 0) return 0;\r\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\r\n    const squaredDiffs = values.map((v) => Math.pow(v - mean, 2));\r\n    return Math.sqrt(squaredDiffs.reduce((a, b) => a + b, 0) / values.length);\r\n  }\r\n\r\n  /**\r\n   * Evaluates if a value passes the rule based on comparator and threshold.\r\n   */\r\n  private evaluateComparator(\r\n    rule: RuleConfig,\r\n    value: number,\r\n    threshold: number\r\n  ): { passed: boolean; direction?: \"low\" | \"high\" } {\r\n    switch (rule.comparator) {\r\n      case \"min\":\r\n        // For \"min\" comparator, value should be <= threshold (e.g., depth check)\r\n        return { passed: value <= threshold };\r\n      case \"max\":\r\n        // For \"max\" comparator, value should be <= threshold (e.g., lockout, forward lean)\r\n        return { passed: value <= threshold };\r\n      case \"mean\":\r\n        // For \"mean\" comparator, value should be >= threshold (e.g., stance width - wider is better)\r\n        const lowerBound = threshold * (1 - this.MEAN_TOLERANCE);\r\n        const upperBound = threshold * (1 + this.MEAN_TOLERANCE);\r\n        if (value < lowerBound) {\r\n          return { passed: false, direction: \"low\" };\r\n        } else if (value > upperBound) {\r\n          return { passed: false, direction: \"high\" };\r\n        }\r\n        return { passed: true };\r\n      case \"std\":\r\n        // For \"std\" comparator, standard deviation should be <= threshold\r\n        return { passed: value <= threshold };\r\n      default:\r\n        return { passed: true };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates debounce counters and returns debounced pass/fail state.\r\n   */\r\n  private updateDebounce(ruleId: string, instantPassed: boolean): boolean {\r\n    // Initialize counters if needed\r\n    if (this.errorCounts[ruleId] === undefined) {\r\n      this.errorCounts[ruleId] = 0;\r\n      this.passCounts[ruleId] = 0;\r\n      this.activeErrors[ruleId] = false;\r\n    }\r\n\r\n    if (instantPassed) {\r\n      // Reset error count, increment pass count\r\n      this.errorCounts[ruleId] = 0;\r\n      this.passCounts[ruleId]++;\r\n\r\n      // Clear active error after enough consecutive passes\r\n      if (this.activeErrors[ruleId] && this.passCounts[ruleId] >= this.ERROR_CLEAR_FRAMES) {\r\n        this.activeErrors[ruleId] = false;\r\n      }\r\n    } else {\r\n      // Reset pass count, increment error count\r\n      this.passCounts[ruleId] = 0;\r\n      this.errorCounts[ruleId]++;\r\n\r\n      // Trigger error after enough consecutive failures\r\n      if (this.errorCounts[ruleId] >= this.ERROR_TRIGGER_FRAMES) {\r\n        this.activeErrors[ruleId] = true;\r\n      }\r\n    }\r\n\r\n    // Return debounced state: error is active only after debounce threshold\r\n    return !this.activeErrors[ruleId];\r\n  }\r\n\r\n  /**\r\n   * Gets all currently active (debounced) errors.\r\n   */\r\n  getActiveErrors(): Feedback[] {\r\n    return this.frameFeedbacks.filter((f) => !f.passed);\r\n  }\r\n\r\n  /**\r\n   * Evaluate frame-level rules for instant feedback.\r\n   * Call this every frame during exercise.\r\n   */\r\n  evaluateFrame(frameData: FrameData, currentPhase: string): Feedback[] {\r\n    const feedbacks: Feedback[] = [];\r\n\r\n    for (const rule of this.config.rules) {\r\n      // Only process frame-level rules\r\n      if (rule.evaluation !== \"FRAME\") continue;\r\n\r\n      // Skip if not in target phase (if specified)\r\n      if (rule.targetPhase && rule.targetPhase !== currentPhase && rule.targetPhase !== \"IDLE\") {\r\n        // Also update debounce to clear errors when not in target phase\r\n        this.updateDebounce(rule.id, true);\r\n        continue;\r\n      }\r\n\r\n      const threshold = this.getThreshold(rule);\r\n      if (threshold === undefined) continue;\r\n\r\n      let measuredValue: number;\r\n      let evalResult: { passed: boolean; direction?: \"low\" | \"high\" };\r\n\r\n      if (rule.type === \"symmetry\") {\r\n        // Symmetry check: compare left vs right\r\n        const left = frameData[rule.feature_left!] ?? NaN;\r\n        const right = frameData[rule.feature_right!] ?? NaN;\r\n        measuredValue = Math.abs(left - right);\r\n        evalResult = this.evaluateComparator(rule, measuredValue, threshold);\r\n      } else if (rule.type === \"stability\") {\r\n        // Stability check: accumulate values and check std dev\r\n        const feature = rule.feature!;\r\n        const value = frameData[feature] ?? NaN;\r\n\r\n        if (!isNaN(value)) {\r\n          if (!this.frameBuffer[feature]) {\r\n            this.frameBuffer[feature] = [];\r\n          }\r\n          this.frameBuffer[feature].push(value);\r\n\r\n          // Only evaluate if we have enough samples\r\n          if (this.frameBuffer[feature].length >= 10) {\r\n            measuredValue = this.calcStd(this.frameBuffer[feature]);\r\n            evalResult = this.evaluateComparator(rule, measuredValue, threshold);\r\n          } else {\r\n            // Not enough data yet\r\n            continue;\r\n          }\r\n        } else {\r\n          continue;\r\n        }\r\n      } else if (rule.type === \"range\") {\r\n        // Range check: instant value comparison\r\n        measuredValue = frameData[rule.feature!] ?? NaN;\r\n        if (isNaN(measuredValue)) continue;\r\n        evalResult = this.evaluateComparator(rule, measuredValue, threshold);\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      // Apply debouncing\r\n      const debouncedPassed = this.updateDebounce(rule.id, evalResult.passed);\r\n\r\n      feedbacks.push({\r\n        ruleId: rule.id,\r\n        errorType: rule.error_type,\r\n        passed: debouncedPassed,\r\n        value: measuredValue,\r\n        threshold,\r\n      });\r\n    }\r\n\r\n    // Store for final rep evaluation\r\n    this.frameFeedbacks = feedbacks;\r\n    return feedbacks;\r\n  }\r\n\r\n  /**\r\n   * Gets the measured value for a rule from the appropriate data source.\r\n   */\r\n  private getMeasuredValue(rule: RuleConfig, repData: RepAggregates, phaseData?: PhaseAggregates): number {\r\n    if (rule.evaluation === \"PHASE\" && phaseData) {\r\n      const phaseValues = phaseData[rule.targetPhase!];\r\n      if (!phaseValues) return NaN;\r\n\r\n      if (rule.type === \"symmetry\") {\r\n        const left = phaseValues[rule.feature_left!] ?? NaN;\r\n        const right = phaseValues[rule.feature_right!] ?? NaN;\r\n        return left - right;\r\n      }\r\n\r\n      // Get the appropriate aggregated value based on comparator\r\n      const feature = rule.feature!;\r\n      if (rule.comparator === \"min\") {\r\n        return phaseValues[`${feature}_min`] ?? phaseValues[feature] ?? NaN;\r\n      } else if (rule.comparator === \"max\") {\r\n        return phaseValues[`${feature}_max`] ?? phaseValues[feature] ?? NaN;\r\n      } else if (rule.comparator === \"mean\") {\r\n        return phaseValues[`${feature}_mean`] ?? phaseValues[feature] ?? NaN;\r\n      } else if (rule.comparator === \"std\") {\r\n        return phaseValues[`${feature}_std`] ?? NaN;\r\n      }\r\n\r\n      return phaseValues[feature] ?? NaN;\r\n    }\r\n\r\n    // rep-level evaluation\r\n    if (rule.type === \"symmetry\") {\r\n      const left = repData[rule.feature_left!] ?? NaN;\r\n      const right = repData[rule.feature_right!] ?? NaN;\r\n      return left - right;\r\n    }\r\n\r\n    const feature = rule.feature!;\r\n    if (rule.comparator === \"min\") {\r\n      return repData[`${feature}_min`] ?? repData[feature] ?? NaN;\r\n    } else if (rule.comparator === \"max\") {\r\n      return repData[`${feature}_max`] ?? repData[feature] ?? NaN;\r\n    } else if (rule.comparator === \"mean\") {\r\n      return repData[`${feature}_mean`] ?? repData[feature] ?? NaN;\r\n    } else if (rule.comparator === \"std\") {\r\n      return repData[`${feature}_std`] ?? NaN;\r\n    }\r\n\r\n    return repData[feature] ?? NaN;\r\n  }\r\n\r\n  /**\r\n   * Evaluate rules using rep-level aggregates only.\r\n   */\r\n  evaluate(data: RepAggregates): Feedback[] {\r\n    return this.evaluateWithPhases(data);\r\n  }\r\n\r\n  /**\r\n   * Evaluate rules using both rep-level and phase-level aggregates.\r\n   * Call this at the end of a rep.\r\n   */\r\n  evaluateWithPhases(repData: RepAggregates, phaseData?: PhaseAggregates): Feedback[] {\r\n    const feedbacks: Feedback[] = [];\r\n\r\n    for (const rule of this.config.rules) {\r\n      const threshold = this.getThreshold(rule);\r\n\r\n      // Skip rule if no threshold for current view\r\n      if (threshold === undefined) {\r\n        continue;\r\n      }\r\n\r\n      // Handle frame-level rules from accumulated data\r\n      if (rule.evaluation === \"FRAME\") {\r\n        const frameFeedback = this.frameFeedbacks.find((f) => f.ruleId === rule.id);\r\n        if (frameFeedback) {\r\n          feedbacks.push(frameFeedback);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Skip phase-evaluation rules if no phase data provided\r\n      if (rule.evaluation === \"PHASE\" && !phaseData) {\r\n        continue;\r\n      }\r\n\r\n      const measuredValue = this.getMeasuredValue(rule, repData, phaseData);\r\n\r\n      // Skip if value couldn't be calculated\r\n      if (isNaN(measuredValue)) {\r\n        continue;\r\n      }\r\n\r\n      // For symmetry rules, compare absolute difference\r\n      const valueToCompare = rule.type === \"symmetry\" ? Math.abs(measuredValue) : measuredValue;\r\n\r\n      const evalResult = this.evaluateComparator(rule, valueToCompare, threshold);\r\n\r\n      feedbacks.push({\r\n        ruleId: rule.id,\r\n        errorType: rule.error_type,\r\n        passed: evalResult.passed,\r\n        value: measuredValue,\r\n        threshold,\r\n        direction: evalResult.direction,\r\n      });\r\n    }\r\n\r\n    return feedbacks;\r\n  }\r\n\r\n  /**\r\n   * Resets frame-level buffers. Call this at the start of each rep.\r\n   */\r\n  reset(): void {\r\n    this.frameBuffer = {};\r\n    this.frameFeedbacks = [];\r\n    // Keep debounce state across reps for continuous feedback\r\n  }\r\n\r\n  /**\r\n   * Full reset including debounce state. Call when starting a new exercise session.\r\n   */\r\n  fullReset(): void {\r\n    this.frameBuffer = {};\r\n    this.frameFeedbacks = [];\r\n    this.errorCounts = {};\r\n    this.passCounts = {};\r\n    this.activeErrors = {};\r\n  }\r\n}\r\n"]}